#import "ligo-generic-fa2/lib/multi_asset/fa2.mligo" "FA2"
#import "./constants.jsligo" "Constants"
#import "./storage.jsligo" "Storage"
#import "./extension.jsligo" "Extension"
#import "./errors.jsligo" "Errors"

type storage = Storage.t
type result = [list<operation>, storage]

type create_token = {
   token_id : nat,
   data     : FA2.TokenMetadata.data,
}

type mint_or_burn = [@layout:comb] {
   owner    : address,
   token_id : nat,
   amount_  : nat,
}

type create_params = [create_token, address, nat]
type permit_params = [key, [signature, bytes]]
type expiry_params = [address, [nat, option<bytes>]]

let create = ([param_create_params, s] : [create_params, storage]) : result => {
    let [param_create_token, owner, amount] = param_create_params;
    let {token_id, data} = param_create_token;
   let _ = Extension.assert_admin(s.extension);
   let md = Storage.add_new_token(s.token_metadata, token_id, data);
   let s = Storage.set_token_metadata(s, md);
   let ledger = FA2.Ledger.increase_token_amount_for_user(s.ledger, owner, token_id, amount);
   let s = FA2.Storage.set_ledger(s, ledger);
   [(list([]) as list<operation>), s]
};

let mint = ([lst, s] : [list<mint_or_burn>, storage]) : result => {
   let _ = Extension.assert_admin(s.extension);
   let process_one = ([ledger, mint_or_burn_param] : [FA2.Ledger.t, mint_or_burn]) : FA2.Ledger.t => {
      let  {owner, token_id, amount_} = mint_or_burn_param;
      let _ = FA2.Storage.assert_token_exist(s, token_id);
      FA2.Ledger.increase_token_amount_for_user(ledger, owner, token_id, amount_);
   };
   let ledger = List.fold_left(process_one, s.ledger, lst);
   let s = FA2.Storage.set_ledger(s, ledger);
   [(list([]) as list<operation>), s]
};

let burn = ([lst, s] : [list<mint_or_burn>, storage]) : result => {
   let _ = Extension.assert_admin(s.extension);
   let process_one = ([ledger, mint_or_burn_param] : [FA2.Ledger.t, mint_or_burn]) : FA2.Ledger.t => {
      let {owner,token_id,amount_} = mint_or_burn_param;
      FA2.Ledger.decrease_token_amount_for_user(ledger, owner, token_id, amount_);
   };
   
   let ledger = List.fold_left(process_one, s.ledger, lst);
   let s = FA2.Storage.set_ledger(s, ledger);
   [(list([]) as list<operation>), s]
};

//(* TZIP-17 *)
let permit = ([lst, s] : [list<permit_params>, storage]) : storage => {
    let process_permit = ([ext, permit] : [Extension.t, permit_params]) : Extension.t => {
        let [pub_key, [sig, hash_]] = permit;
        let packed = Bytes.pack([(Tezos.get_chain_id()), Tezos.get_self_address()], [ext.counter, hash_]);
        if (Crypto.check(pub_key, sig, packed)) {
            let sender_ = Tezos.address (Tezos.implicit_account (Crypto.hash_key(pub_key)));
            let permit_key = [sender_, hash_];
            match (Big_map.find_opt(permit_key, ext.permits), {
                None: () => Extension.add_permit(ext, permit_key),
                Some: (submission_timestamp: timestamp) => {
                    let _ = Extension._check_not_expired(s.extension, submission_timestamp, permit_key);
                    Extension.update_permit(ext, permit_key)
                }
            })
        } else { 
        //([%Michelson ({| { FAILWITH } |} : string * bytes -> Extension.t)]) (Errors.missigned, packed)
            (Michelson `{FAILWITH}` as ((n: [string, bytes]) => Extension.t)) ([Errors.missigned, packed])
        }
    };
    let extension = List.fold_left(process_permit, s.extension, lst);
    return { ...s, extension : extension }
};

//(* TZIP-17 *)
let set_expiry = ([p, s] : [expiry_params, storage]) : storage => {
    let [user_address, [seconds, permit_hash_opt]] = p;
    if (seconds > s.extension.max_expiry) {
        return (failwith(Errors.max_seconds_exceeded) as storage)
    } else { 
        if (Tezos.get_sender() != user_address) {
            return (failwith(Errors.forbidden_expiry_update) as storage)
        } else {
            let new_storage =
                match (permit_hash_opt, {
                    None: () => {
                        return {...s, extension : { ...s.extension, 
                            user_expiries : Big_map.add(user_address, (Some(seconds)), s.extension.user_expiries) 
                        }};                        
                    },
                    Some: (permit_hash: bytes) => {
                        return {
                            ...s, extension : {...s.extension, permit_expiries : Big_map.add(
                                [user_address, permit_hash],
                                (Some(seconds)),
                                s.extension.permit_expiries)
                        }}
                    }
                });
            new_storage
        }
    }
};

//(* TZIP-17 implementation of TZIP-12 Transfer *)
let transfer_permitted = ([t, s]: [FA2.transfer, storage]) : storage => {
    let make_transfer = ([acc, t] : [[FA2.Ledger.t, Extension.t], FA2.transfer_from]) : [FA2.Ledger.t, Extension.t] => {
        let [l, e] = acc;
        let [is_transfer_authorized, e] = Extension.transfer_presigned(e, t);
        List.fold(
          ( ([acc, dst] : [[FA2.Ledger.t, Extension.t], FA2.atomic_trans]) => {
            let _ = FA2.Storage.assert_token_exist(s, dst.token_id);
            // let _ = if (!is_transfer_authorized) {
            //     FA2.Operators.assert_authorisation s.operators t.from_ dst.token_id
            // };
            if (!is_transfer_authorized) {
                let _ = FA2.Operators.assert_authorisation(s.operators, t.from_, dst.token_id);

                let [ledger, ext] = acc;
                let ledger = FA2.Ledger.decrease_token_amount_for_user(ledger, t.from_, dst.token_id, dst.amount);
                let ledger = FA2.Ledger.increase_token_amount_for_user(ledger, dst.to_, dst.token_id, dst.amount);
                [ledger, ext]
            } else {
                let [ledger, ext] = acc;
                let ledger = FA2.Ledger.decrease_token_amount_for_user(ledger, t.from_, dst.token_id, dst.amount);
                let ledger = FA2.Ledger.increase_token_amount_for_user(ledger, dst.to_, dst.token_id, dst.amount);
                [ledger, ext]
            }
            
            // let [ledger, ext] = acc;
            // let ledger = FA2.Ledger.decrease_token_amount_for_user(ledger, t.from_, dst.token_id, dst.amount);
            // let ledger = FA2.Ledger.increase_token_amount_for_user(ledger, dst.to_, dst.token_id, dst.amount);
            // [ledger, ext]
          }), t.tx, [l, e]);
    };
    let [new_ledger, new_ext] = List.fold(make_transfer, t, [s.ledger, s.extension]);
    return { ...s, ledger : new_ledger, extension : new_ext }
};

type parameter = [@layout:comb]
    ["Transfer", FA2.transfer] |
    ["Balance_of", FA2.balance_of] |
    ["Update_operators", FA2.update_operators] |
    ["Create_token", [create_token, address, nat]] |
    ["Mint_token", list<mint_or_burn>] |
    ["Burn_token", list<mint_or_burn>] |
    ["Permit", list<permit_params>] |
    ["SetExpiry", expiry_params] |
    ["SetAdmin", address]

let main = ([p,s]:[parameter, storage]): result => {
    return match (p, {
        Transfer:         (p: FA2.transfer) => [Constants.no_operation, transfer_permitted(p,s)],
        Balance_of:       (p: FA2.balance_of) => FA2.balance_of(p, s),
        Update_operators: (p: FA2.update_operators) => FA2.update_ops(p, s),
        Create_token:     (p: [create_token, address, nat]) => create(p, s),
        Mint_token:       (p: list<mint_or_burn>) => mint(p, s),
        Burn_token:       (p: list<mint_or_burn>) => burn(p, s),
        Permit:           (p: list<permit_params>) => [Constants.no_operation, permit(p, s)],
        SetExpiry:        (p: expiry_params) => [Constants.no_operation, set_expiry(p, s)],
        SetAdmin:         (p: address) => [Constants.no_operation, { ...s, extension : Extension.set_admin(s.extension, p) }]
        })
};

// (*
//     Off-chain views required by TZIP-17

//     Command to run to get the micheline expressions to put in the metadata:

//     ligo compile expression cameligo '_get_counter' \
//         --init-file src/main.mligo \
//         --project-root . \
//         --michelson-format json
// *)

let _get_default_expiry = ([_n,s]: [nat, storage]) : nat => {
    return s.extension.default_expiry
};

let _get_counter = ([_n,s]: [nat, storage]) : nat => {
    return s.extension.counter
};

