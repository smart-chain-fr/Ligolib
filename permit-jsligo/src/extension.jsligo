#import "ligo-generic-fa2/lib/multi_asset/fa2.mligo" "FA2"
#import "./errors.jsligo" "Errors"

type seconds = nat;
export type permitKey = [address, bytes];
export type permits = big_map<permitKey, timestamp>;
export type userExpiries = big_map<address, option<seconds>>;
export type permitExpiries = big_map<permitKey, option<seconds>>;

// token_id -> total_supply
export type tokenTotalSupply = big_map<FA2.Ledger.token_id, nat>;

export type t = {
    admin: address,
    counter: nat,
    defaultExpiry: seconds,
    maxExpiry: seconds,
    permits: permits,
    userExpiries: userExpiries,
    permitExpiries: permitExpiries,
    tokenTotalSupply : tokenTotalSupply
};

let get_user_defined_expiry = ([from_, ext]: [address, t]) : option<seconds> => {
    return match (Big_map.find_opt(from_, ext.userExpiries), {
        None: () => (Some(ext.defaultExpiry)),
        Some: (exp: option<seconds>) => exp
    });
};

let get_expiry = ([ext, paramPermitKey]: [t, permitKey]) : seconds => {
    match ((Big_map.find_opt([paramPermitKey[0], paramPermitKey[1]], ext.permitExpiries) as option<option<seconds>>), {
        None: () => {
                match ((Big_map.find_opt(paramPermitKey[0], ext.userExpiries) as option<option<seconds>>), {
                    None: () => ext.defaultExpiry,
                    Some: (exp: option<seconds>) => {
                        match (exp, {
                            None: () => ext.defaultExpiry,
                            Some: (t: seconds) => t
                        })
                    }
                })
            },
        Some: (p: option<seconds>) => {
                match (p, {
                    None: () => ext.defaultExpiry,
                    Some: (exp: seconds) => exp
                })
            }
    })
};


export let assert_admin = (ext : t) : unit =>
    assert_with_error((Tezos.get_sender() == ext.admin), Errors.requiresAdmin);

export let set_admin = ([ext, admin] : [t, address]) : t => {
    let _ = assert_admin(ext);
    return { ...ext, admin : admin };
};

let get_supply = ([supply, token_id] : [tokenTotalSupply, FA2.Ledger.token_id]) : nat =>
    match (Big_map.find_opt(token_id, supply), { 
        Some: (a: nat) => a,
        None: () => (failwith(FA2.Errors.undefined_token) as nat)
   })

export let set_supply = ([ext, supply] : [t, tokenTotalSupply]) : t => {
    return { ...ext, tokenTotalSupply : supply }
};

export let create_supply = ([supply, new_token_id, amount_] : [tokenTotalSupply, FA2.Ledger.token_id, nat]) : tokenTotalSupply => {
    return Big_map.add(new_token_id, amount_, supply)
};

export let increase_supply = ([supply, token_id,amount_] : [tokenTotalSupply, FA2.Ledger.token_id, nat]) : tokenTotalSupply => {
    let cur_amount = get_supply(supply, token_id);
    let new_amount = cur_amount + amount_;
    Big_map.update(token_id, (Some(new_amount)), supply)
};

export let decrease_supply = ([supply, token_id, amount_] : [tokenTotalSupply, FA2.Ledger.token_id, nat]) : tokenTotalSupply => {
    let cur_amount = get_supply(supply, token_id);
    let new_supply = abs(cur_amount - amount_);
    Big_map.update(token_id, (Some(new_supply)), supply);
};
 
export let add_permit = ([ext, paramPermitKey] : [t, permitKey]) : t => {
    let now = Tezos.get_now();
    return { ...ext,
        permits : Big_map.add(paramPermitKey, now, ext.permits),
        counter : ext.counter + (1 as nat)
    }
};

export let update_permit = ([ext, paramPermitKey] : [t, permitKey]) : t => {
    let now = Tezos.get_now();
    return { ...ext,
        permits : Big_map.update(paramPermitKey, (Some(now)), ext.permits),
        counter : ext.counter + (1 as nat)
    }
};

export let _check_not_expired = ([ext, submission_timestamp, paramPermitKey]: [t, timestamp, permitKey]) : unit => {
    let effective_expiry: seconds = get_expiry(ext, paramPermitKey);
    assert_with_error((abs (Tezos.get_now() - submission_timestamp) >= effective_expiry), Errors.dupPermit);
};

export let transfer_presigned = ([ext, params]: [t, FA2.transfer_from]): [bool, t] => {
    let params_hash = Crypto.blake2b(Bytes.pack(params));
    let permit_submit_time: timestamp =
        match (Big_map.find_opt([params.from_, params_hash], ext.permits), {
            None: () => (0 as timestamp),
            Some: (exp: timestamp) => exp
        });
    if (permit_submit_time == (0 as timestamp)) {
        return [false, ext]
    } else {
        let effective_expiry =
            match (Big_map.find_opt([params.from_, params_hash], ext.permitExpiries), {
                None: () => {
                    match (Big_map.find_opt(params.from_, ext.userExpiries), {
                        None: () => (Some(ext.defaultExpiry)),
                        Some: (exp: option<seconds>) => exp
                    })
                },
                Some: (exp: option<seconds>) => exp
            });
        return match (effective_expiry, {
            None: () => (failwith("NO_EXPIRY_FOUND") as [bool, t]),
            Some: (effective_exp: seconds) => {  
                let permits = Big_map.remove([params.from_, params_hash], ext.permits);
                let is_authorised = abs ((Tezos.get_now()) - permit_submit_time) < effective_exp;
                [is_authorised, { ...ext, permits : permits }]
            }
        });
    }
};